package cmd

import (
	"fmt"
	"sort"
	"strings"

	"github.com/aquasecurity/trivy/pkg/types"
	"github.com/fritterhoff/vulnerability-bot/bot"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	Title  string
	Path   string
	Source string
	Target string
	Old    string
	New    string
	Assign string
)

func init() {
	rootCmd.AddCommand(mrCmd)
	mrCmd.Flags().StringVar(&Old, "old", "", "old image (may be path or image spec)")
	mrCmd.Flags().StringVar(&New, "new", "", "new image (may be path or image spec)")
	mrCmd.Flags().StringVarP(&Title, "title", "t", "", "title of the MR")
	mrCmd.Flags().StringVar(&Source, "source", "", "source branch of the MR")
	mrCmd.Flags().StringVar(&Target, "target", "", "target branch of the MR")
	mrCmd.Flags().StringVar(&Path, "path", "", "path to patch")
	mrCmd.Flags().StringVar(&Assign, "assign", "", "user to assign the MR to")
	required("old")
	required("new")
	required("title")
	required("source")
	required("target")
	required("path")
}

func required(tag string) {
	err := mrCmd.MarkFlagRequired(tag)
	if err != nil {
		log.Fatal().Err(err).Msgf("Making %s required failed", tag)
	}
}

func generateContent(oldVulns map[string]map[string]types.DetectedVulnerability, newVulns map[string]map[string]types.DetectedVulnerability) string {
	content := "# Automatic vulnerability patches \n"
	content += "## Before\n\n"
	content += sortedTable(oldVulns)
	content += "\n## After\n"
	content += sortedTable(newVulns)
	return content
}

func sortedTable(oldVulns map[string]map[string]types.DetectedVulnerability) string {
	content := "Target | Vuln. ID | Package Name | Installed v. | Fixed v. \n -|-|-|-|- \n"
	targets := make([]string, 0, len(oldVulns))
	for k := range oldVulns {
		targets = append(targets, k)
	}
	sort.Strings(targets)
	for _, t := range targets {
		vulns := make([]string, 0, len(oldVulns[t]))
		for k := range oldVulns[t] {
			vulns = append(vulns, k)
		}
		sort.Strings(vulns)
		for _, k := range vulns {
			v := oldVulns[t][k]
			content += fmt.Sprintf("%s| %s | %s | %s | %s \n", t, v.VulnerabilityID, v.PkgName, v.InstalledVersion, v.FixedVersion)
		}
	}
	return content
}

var mrCmd = &cobra.Command{
	Use:   "handle",
	Short: "Handle images and creates or updates a merge request.",
	Long:  `Handle images and creates or updates a merge request. The merge request gets identified by its title. In case of an existing change for the source branch the operation gets aborted`,
	Run: func(cmd *cobra.Command, args []string) {
		viper.Set("show-success", true)
		c := bot.NewClient()

		delta, oldVulns, newVulns := bot.Diff(Old, New)
		if delta {
			content := generateContent(oldVulns, newVulns)
			// Source and target get flipped in this case as we want to fix the file at the source using the targets vesion
			mr, err := c.FindExistingMergeRequest(Title, Source)
			if err != nil {
				return
			}
			if strings.TrimSpace(mr.Description) == strings.TrimSpace(content) {
				log.Info().Msg("No update required. Merge request is at same state.")
				return
			}
			c.FixFile(Target, Source, Path)
			c.RunMergeRequest(Title, content, Source, Target, Assign, mr)
		}

	},
}
