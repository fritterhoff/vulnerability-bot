package bot

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/aquasecurity/fanal/analyzer/config"
	"github.com/aquasecurity/fanal/applier"
	"github.com/aquasecurity/fanal/artifact"
	image2 "github.com/aquasecurity/fanal/artifact/image"
	"github.com/aquasecurity/fanal/cache"
	"github.com/aquasecurity/fanal/image"
	types2 "github.com/aquasecurity/fanal/types"
	"github.com/aquasecurity/trivy-db/pkg/db"
	dbTypes "github.com/aquasecurity/trivy-db/pkg/types"
	"github.com/aquasecurity/trivy/pkg/commands/operation"
	"github.com/aquasecurity/trivy/pkg/detector/ospkg"
	"github.com/aquasecurity/trivy/pkg/report"
	"github.com/aquasecurity/trivy/pkg/scanner"
	"github.com/aquasecurity/trivy/pkg/scanner/local"
	"github.com/aquasecurity/trivy/pkg/types"
	"github.com/rs/zerolog/log"
)

func equal(a, b map[string]map[string]types.DetectedVulnerability) bool {
	if len(a) != len(b) {
		return false
	}
	for i, r1 := range a {
		if r2, ok := b[i]; !ok {
			return false
		} else {
			if len(r1) != len(r2) {
				return false
			}
			for x := range r1 {
				if _, ok := r1[x]; !ok {
					return false
				}
			}
		}
	}
	return true
}
func Diff(old string, new string) (bool, map[string]map[string]types.DetectedVulnerability, map[string]map[string]types.DetectedVulnerability) {
	r1 := Scan(old)
	r2 := Scan(new)
	vuln1 := make(map[string]map[string]types.DetectedVulnerability)
	vuln2 := make(map[string]map[string]types.DetectedVulnerability)

	for _, r := range r1 {
		vuln1[r.Target] = filter(r.Vulnerabilities)
	}
	for _, r := range r2 {
		vuln2[r.Target] = filter(r.Vulnerabilities)
	}

	if !equal(vuln1, vuln2) {
		return true, vuln1, vuln2
	} else {
		return false, nil, nil
	}
}

func filter(vulns []types.DetectedVulnerability) map[string]types.DetectedVulnerability {
	uniqVulns := make(map[string]types.DetectedVulnerability)
	for _, vuln := range vulns {
		// Patch empty severity
		if vuln.Severity == "" {
			vuln.Severity = dbTypes.SeverityUnknown.String()
		}

		// Ignore unfixed vulnerabilities
		if vuln.FixedVersion == "" {
			continue
		}

		// Check if there is a duplicate vulnerability
		key := fmt.Sprintf("%s/%s/%s", vuln.VulnerabilityID, vuln.PkgName, vuln.InstalledVersion)
		if old, ok := uniqVulns[key]; ok && old.FixedVersion < vuln.FixedVersion {
			continue
		}
		uniqVulns[key] = vuln
	}
	return uniqVulns
}

func Scan(spec string) report.Results {

	localArtifactCache, _ := cache.NewFSCache("/tmp")
	err := operation.DownloadDB("", "/tmp", false, false, false)
	if err != nil {
		return nil
	}
	err = db.Init("/tmp")
	if err != nil {
		log.Log().Err(err).Msg("Init failed.")
		return nil
	}
	defer func() {
		err := db.Close()
		if err != nil {
			log.Log().Err(err).Msg("Failed closing database.")
		}
		err = localArtifactCache.Close()
		if err != nil {
			log.Log().Err(err).Msg("Failed closing cache.")
			return
		}
	}()
	applierApplier := applier.NewApplier(localArtifactCache)
	detector := ospkg.Detector{}
	dockerOpt, err := types.GetDockerOption(5 * time.Minute)
	if err != nil {
		log.Log().Err(err)
		return nil
	}
	artifactOpt := artifact.Option{
		Quiet:   false,
		Offline: false,
	}
	var configScannerOptions config.ScannerOption
	localScanner := local.NewScanner(applierApplier, detector)
	var typesImage types2.Image
	var cleanup func()

	if strings.HasSuffix(strings.TrimSpace(spec), ".tar.gz") {
		typesImage, err = image.NewArchiveImage(spec)
	} else {
		typesImage, cleanup, err = image.NewDockerImage(context.Background(), spec, dockerOpt)
	}

	if err != nil {
		log.Log().Err(err).Msg("Failed loading image.")
		return nil
	}
	artifactArtifact, err := image2.NewArtifact(typesImage, localArtifactCache, artifactOpt, configScannerOptions)
	if err != nil {
		cleanup()
		log.Log().Err(err).Msg("Failed creating trivy artifact.")
		return nil
	}
	scannerScanner := scanner.NewScanner(localScanner, artifactArtifact)
	scanOptions := types.ScanOptions{
		VulnType:       []string{types.VulnTypeOS, types.VulnTypeLibrary},
		SecurityChecks: []string{types.SecurityCheckVulnerability},
	}
	scanArtifact, err := scannerScanner.ScanArtifact(context.Background(), scanOptions)
	if err != nil {
		log.Log().Err(err).Msg("Scanning failed")
		return nil
	}
	return scanArtifact.Results
}
