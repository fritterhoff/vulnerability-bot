package bot

import (
	"fmt"

	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/xanzy/go-gitlab"
)

type Client struct {
	*gitlab.Client
}

func NewClient() *Client {
	log.Debug().Str("gitlab.host", viper.GetString("gitlab.host")).Msg("connecting to gitlab server")

	client, err := gitlab.NewClient(viper.GetString("gitlab.token"), gitlab.WithBaseURL(viper.GetString("gitlab.host")))

	if err != nil {
		panic("cannot create a gitlab client")
	}

	return &Client{client}
}

func (c *Client) FindExistingMergeRequest(title string, source string) (*gitlab.MergeRequest, error) {
	p := viper.GetString("gitlab.project")
	// By definition only one MR per branch can be opened, so this query will return either zero or one merge requests.
	list, _, err := c.MergeRequests.ListProjectMergeRequests(p,
		&gitlab.ListProjectMergeRequestsOptions{
			SourceBranch: gitlab.String(source),
			State:        gitlab.String("opened"),
		})
	if err != nil {
		log.Fatal().Err(err).Msg("Querying for merge requests failed")
		return nil, err
	}
	if len(list) != 0 {
		for _, mr := range list {
			if mr.Title == title {
				return mr, nil
			} else {
				log.Fatal().Err(fmt.Errorf("existing mr for source branch %s found, but different title: %s", source, mr.Title)).Msg("Creating/Updating merge request failed")
			}
		}
	}
	return nil, nil
}

func (c *Client) RunMergeRequest(title string, content string, source string, target string, assign string, existing *gitlab.MergeRequest) {

	p := viper.GetString("gitlab.project")

	assignId := 0
	if assign != "" {
		mem, _, err := c.ProjectMembers.ListAllProjectMembers(p, &gitlab.ListProjectMembersOptions{
			Query: &assign,
		})
		if err != nil {
			log.Fatal().Err(err).Msg("Querying for project member failed")
		} else {
			assignId = mem[0].ID
		}
	}
	if existing != nil {
		options := &gitlab.UpdateMergeRequestOptions{
			Title:              gitlab.String(title),
			Description:        gitlab.String(content),
			RemoveSourceBranch: gitlab.Bool(true),
			Squash:             gitlab.Bool(true),
		}
		if assign != "" {
			options.AssigneeID = gitlab.Int(assignId)
		}
		_, _, err := c.MergeRequests.UpdateMergeRequest(p, existing.IID, options)
		if err != nil {
			log.Fatal().Err(err).
				Msg("Updating merge request failed")
		}
	} else {
		log.Info().Msg("No existing merge requests found. Creating new.")
		options := &gitlab.CreateMergeRequestOptions{
			Title:              gitlab.String(title),
			Description:        gitlab.String(content),
			SourceBranch:       gitlab.String(source),
			TargetBranch:       gitlab.String(target),
			RemoveSourceBranch: gitlab.Bool(true),
			Squash:             gitlab.Bool(true),
		}
		if assign != "" {
			options.AssigneeID = gitlab.Int(assignId)
		}
		_, _, err := c.MergeRequests.CreateMergeRequest(p, options)
		if err != nil {
			log.Fatal().Err(err).
				Msg("Creating merge request failed")
		}
	}
}
