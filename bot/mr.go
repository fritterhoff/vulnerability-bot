package bot

import (
	"encoding/base64"
	"fmt"
	"strings"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/xanzy/go-gitlab"
)

type Client struct {
	*gitlab.Client
}

func NewClient() *Client {
	log.Debug().Str("gitlab.host", viper.GetString("gitlab.host")).Msg("connecting to gitlab server")

	client, err := gitlab.NewClient(viper.GetString("gitlab.token"), gitlab.WithBaseURL(viper.GetString("gitlab.host")))

	if err != nil {
		panic("cannot create a gitlab client")
	}

	return &Client{client}
}

func (c *Client) FixFile(vulnerable, fix, path string) {
	pid := viper.GetString("gitlab.project")
	branches, _, err := c.Branches.ListBranches(pid, &gitlab.ListBranchesOptions{Search: &fix})
	if err != nil {
		log.Fatal().Err(err)
		return
	}
	exists := false
	for _, branch := range branches {
		if branch.Name == fix {
			exists = true
		}
	}

	if exists {
		log.Info().Msg("Branch found. Reusing existing.")
		_, _, err := c.Branches.GetBranch(pid, fix)
		if err != nil {
			log.Fatal().Err(err)
		}
	} else {
		log.Info().Msg("Branch not found. Creating new one.")
		_, _, err = c.Branches.CreateBranch(pid, &gitlab.CreateBranchOptions{Branch: &fix, Ref: &vulnerable})
		if err != nil {
			log.Fatal().Err(err).Msg("Failed create new branch")
			return
		}
	}

	f, _, _ := c.RepositoryFiles.GetFile(pid, path, &gitlab.GetFileOptions{
		Ref: &vulnerable,
	})
	content := f.Content
	if f.Encoding == "base64" {
		x, _ := base64.StdEncoding.DecodeString(content)
		content = string(x)
	}
	content = strings.Replace(content, "# VULN_SCAN_TIME=", fmt.Sprintf("# VULN_SCAN_TIME=%v", time.Now()), -1)
	if f.Encoding == "base64" {
		content = base64.StdEncoding.EncodeToString([]byte(content))
	}
	msg := "Automated vulnerability patch"
	name := "Vulnerabiltiy Bot"
	patch := gitlab.CommitActionOptions{
		Action:   gitlab.FileAction(gitlab.FileUpdate),
		FilePath: &path,
		Content:  &content,
		Encoding: &f.Encoding,
	}
	_, _, err = c.Commits.CreateCommit(pid, &gitlab.CreateCommitOptions{Branch: &fix, CommitMessage: &msg, AuthorName: &name, Actions: []*gitlab.CommitActionOptions{&patch}})
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to update file.")
		return
	}
}

func (c *Client) RunMergeRequest(title string, content string, source string, target string) {
	open := "opened"
	list, resp, err := c.MergeRequests.ListProjectMergeRequests(viper.GetString("gitlab.project"),
		&gitlab.ListProjectMergeRequestsOptions{
			SourceBranch: gitlab.String(source),
			State:        &open,
		})
	if err != nil {
		log.Fatal().Err(err).
			Msg("Querying for merge requests failed")
		return
	}
	log.Debug().Str("status", resp.Status)
	if len(list) != 0 {
		if len(list) > 1 {
			log.Warn().Msgf("Found %d merge requests matching the requested pattern", len(list))
		}
		for _, mr := range list {
			if mr.Title == title {
				_, _, err := c.MergeRequests.UpdateMergeRequest(viper.GetString("gitlab.project"), mr.IID, &gitlab.UpdateMergeRequestOptions{
					Description: gitlab.String(content),
				})
				if err != nil {
					log.Fatal().Err(err).
						Msg("Updating merge request failed")
				}
			} else {
				log.Fatal().Err(fmt.Errorf("existing mr for source branch %s found (title: %s)", source, mr.Title)).Msg("Creating/Updating merge request failed")
			}
		}
	} else {
		log.Info().Msg("No existing merge requests found. Creating new.")
		_, _, err := c.MergeRequests.CreateMergeRequest(viper.GetString("gitlab.project"), &gitlab.CreateMergeRequestOptions{
			Title:              gitlab.String(title),
			Description:        gitlab.String(content),
			SourceBranch:       gitlab.String(source),
			TargetBranch:       gitlab.String(target),
			RemoveSourceBranch: gitlab.Bool(true),
			Squash:             gitlab.Bool(true),
		})
		if err != nil {
			log.Fatal().Err(err).
				Msg("Creating merge request failed")
		}
	}
}
